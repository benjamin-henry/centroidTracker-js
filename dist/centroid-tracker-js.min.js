(()=>{var e={10:e=>{e.exports=class{constructor(e=50){this.nextObjectID=0,this.objects={},this.disappeared={},this.maxDisappeared=e}euclideanDistance(e,t){const s=e[0]-t[0],i=e[1]-t[1];return Math.sqrt(s*s+i*i)}register(e){this.objects[this.nextObjectID]=e,this.disappeared[this.nextObjectID]=0,this.nextObjectID++}deregister(e){delete this.objects[e],delete this.disappeared[e]}update(e){if(0==e.length)return Object.keys(this.disappeared).forEach((e=>{this.disappeared[e]+=1,this.disappeared[e]>this.maxDisappeared&&this.deregister(e)})),Object.assign({},this.objects);let t=[];for(let s=0;s<e.length;s++)t.push([~~((e[s].upperLeft[0]+e[s].bottomRight[0])/2),~~((e[s].upperLeft[1]+e[s].bottomRight[1])/2)]);if(0==Object.keys(this.objects).length)t.forEach((e=>{this.register(e)}));else{const e=Object.keys(this.objects),s=e.map((e=>this.objects[e]));let i=new Array(this.objects.length);for(let e=0;e<s.length;e++){i[e]=new Array(t.length);for(let r=0;r<t.length;r++)i[e][r]=this.euclideanDistance(t[r],s[e])}let r=[],h=[];for(let e=0;e<i.length;e++){r.push(Math.min(...i[e]));let t=i[e][0];h.push(0);for(let s=1;s<i[e].length;s++)i[e][s]<=t&&(t=i[e][s],h[e]=s)}const a=r.map(((e,t)=>[e,t])).sort().map((e=>e[1]));let n=[];for(let e=0;e<h.length;e++)n.push(h[a[e]]);let p=[],o=[];for(let s=0;s<a.length;s++){if(p.includes(a[s])||o.includes(n[s]))continue;const i=e[a[s]];this.objects[i]=t[n[s]],this.disappeared[i]=0,p.push(a[s]),o.push(n[s])}let c=[],l=[];for(let e=0;e<i.length;e++)p.includes(e)||c.push(e);for(let e=0;e<i[0].length;e++)o.includes(e)||l.push(e);i.length>=i[0].length?c.forEach((t=>{const s=e[t];this.disappeared[s]+=1,this.disappeared[s]>this.maxDisappeared&&this.deregister(s)})):l.forEach((e=>{this.register(t[e])}))}return Object.assign({},this.objects)}}}},t={};!function s(i){var r=t[i];if(void 0!==r)return r.exports;var h=t[i]={exports:{}};return e[i](h,h.exports,s),h.exports}(10)})();